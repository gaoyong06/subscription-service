// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: subscription.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Plan with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Plan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plan with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PlanMultiError, or nil if none found.
func (m *Plan) ValidateAll() error {
	return m.validate(true)
}

func (m *Plan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlanId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Price

	// no validation rules for Currency

	// no validation rules for DurationDays

	// no validation rules for Type

	// no validation rules for AppId

	if len(errors) > 0 {
		return PlanMultiError(errors)
	}

	return nil
}

// PlanMultiError is an error wrapping multiple validation errors returned by
// Plan.ValidateAll() if the designated constraints aren't met.
type PlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlanMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlanMultiError) AllErrors() []error { return m }

// PlanValidationError is the validation error returned by Plan.Validate if the
// designated constraints aren't met.
type PlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlanValidationError) ErrorName() string { return "PlanValidationError" }

// Error satisfies the builtin error interface
func (e PlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlanValidationError{}

// Validate checks the field values on ListPlansRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPlansRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlansRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlansRequestMultiError, or nil if none found.
func (m *ListPlansRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlansRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	if len(errors) > 0 {
		return ListPlansRequestMultiError(errors)
	}

	return nil
}

// ListPlansRequestMultiError is an error wrapping multiple validation errors
// returned by ListPlansRequest.ValidateAll() if the designated constraints
// aren't met.
type ListPlansRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlansRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlansRequestMultiError) AllErrors() []error { return m }

// ListPlansRequestValidationError is the validation error returned by
// ListPlansRequest.Validate if the designated constraints aren't met.
type ListPlansRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlansRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlansRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlansRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlansRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlansRequestValidationError) ErrorName() string { return "ListPlansRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListPlansRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlansRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlansRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlansRequestValidationError{}

// Validate checks the field values on CreatePlanRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePlanRequestMultiError, or nil if none found.
func (m *CreatePlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := CreatePlanRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	if m.GetPrice() < 0 {
		err := CreatePlanRequestValidationError{
			field:  "Price",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCurrency()) != 3 {
		err := CreatePlanRequestValidationError{
			field:  "Currency",
			reason: "value length must be 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if m.GetDurationDays() <= 0 {
		err := CreatePlanRequestValidationError{
			field:  "DurationDays",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := CreatePlanRequestValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreatePlanRequestMultiError(errors)
	}

	return nil
}

// CreatePlanRequestMultiError is an error wrapping multiple validation errors
// returned by CreatePlanRequest.ValidateAll() if the designated constraints
// aren't met.
type CreatePlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePlanRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePlanRequestMultiError) AllErrors() []error { return m }

// CreatePlanRequestValidationError is the validation error returned by
// CreatePlanRequest.Validate if the designated constraints aren't met.
type CreatePlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePlanRequestValidationError) ErrorName() string {
	return "CreatePlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePlanRequestValidationError{}

// Validate checks the field values on CreatePlanReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePlanReplyMultiError, or nil if none found.
func (m *CreatePlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePlanReplyValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePlanReplyValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePlanReplyValidationError{
				field:  "Plan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePlanReplyMultiError(errors)
	}

	return nil
}

// CreatePlanReplyMultiError is an error wrapping multiple validation errors
// returned by CreatePlanReply.ValidateAll() if the designated constraints
// aren't met.
type CreatePlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePlanReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePlanReplyMultiError) AllErrors() []error { return m }

// CreatePlanReplyValidationError is the validation error returned by
// CreatePlanReply.Validate if the designated constraints aren't met.
type CreatePlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePlanReplyValidationError) ErrorName() string { return "CreatePlanReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreatePlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePlanReplyValidationError{}

// Validate checks the field values on UpdatePlanRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePlanRequestMultiError, or nil if none found.
func (m *UpdatePlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlanId()) < 1 {
		err := UpdatePlanRequestValidationError{
			field:  "PlanId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Price

	// no validation rules for Currency

	// no validation rules for DurationDays

	// no validation rules for Type

	if len(errors) > 0 {
		return UpdatePlanRequestMultiError(errors)
	}

	return nil
}

// UpdatePlanRequestMultiError is an error wrapping multiple validation errors
// returned by UpdatePlanRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdatePlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePlanRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePlanRequestMultiError) AllErrors() []error { return m }

// UpdatePlanRequestValidationError is the validation error returned by
// UpdatePlanRequest.Validate if the designated constraints aren't met.
type UpdatePlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePlanRequestValidationError) ErrorName() string {
	return "UpdatePlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePlanRequestValidationError{}

// Validate checks the field values on UpdatePlanReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePlanReplyMultiError, or nil if none found.
func (m *UpdatePlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePlanReplyValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePlanReplyValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePlanReplyValidationError{
				field:  "Plan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePlanReplyMultiError(errors)
	}

	return nil
}

// UpdatePlanReplyMultiError is an error wrapping multiple validation errors
// returned by UpdatePlanReply.ValidateAll() if the designated constraints
// aren't met.
type UpdatePlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePlanReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePlanReplyMultiError) AllErrors() []error { return m }

// UpdatePlanReplyValidationError is the validation error returned by
// UpdatePlanReply.Validate if the designated constraints aren't met.
type UpdatePlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePlanReplyValidationError) ErrorName() string { return "UpdatePlanReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePlanReplyValidationError{}

// Validate checks the field values on DeletePlanRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeletePlanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePlanRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePlanRequestMultiError, or nil if none found.
func (m *DeletePlanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePlanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlanId()) < 1 {
		err := DeletePlanRequestValidationError{
			field:  "PlanId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePlanRequestMultiError(errors)
	}

	return nil
}

// DeletePlanRequestMultiError is an error wrapping multiple validation errors
// returned by DeletePlanRequest.ValidateAll() if the designated constraints
// aren't met.
type DeletePlanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePlanRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePlanRequestMultiError) AllErrors() []error { return m }

// DeletePlanRequestValidationError is the validation error returned by
// DeletePlanRequest.Validate if the designated constraints aren't met.
type DeletePlanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePlanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePlanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePlanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePlanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePlanRequestValidationError) ErrorName() string {
	return "DeletePlanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePlanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePlanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePlanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePlanRequestValidationError{}

// Validate checks the field values on DeletePlanReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeletePlanReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePlanReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePlanReplyMultiError, or nil if none found.
func (m *DeletePlanReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePlanReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlanId

	if len(errors) > 0 {
		return DeletePlanReplyMultiError(errors)
	}

	return nil
}

// DeletePlanReplyMultiError is an error wrapping multiple validation errors
// returned by DeletePlanReply.ValidateAll() if the designated constraints
// aren't met.
type DeletePlanReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePlanReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePlanReplyMultiError) AllErrors() []error { return m }

// DeletePlanReplyValidationError is the validation error returned by
// DeletePlanReply.Validate if the designated constraints aren't met.
type DeletePlanReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePlanReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePlanReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePlanReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePlanReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePlanReplyValidationError) ErrorName() string { return "DeletePlanReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeletePlanReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePlanReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePlanReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePlanReplyValidationError{}

// Validate checks the field values on ListPlansReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPlansReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlansReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPlansReplyMultiError,
// or nil if none found.
func (m *ListPlansReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlansReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPlans() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPlansReplyValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPlansReplyValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPlansReplyValidationError{
					field:  fmt.Sprintf("Plans[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPlansReplyMultiError(errors)
	}

	return nil
}

// ListPlansReplyMultiError is an error wrapping multiple validation errors
// returned by ListPlansReply.ValidateAll() if the designated constraints
// aren't met.
type ListPlansReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlansReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlansReplyMultiError) AllErrors() []error { return m }

// ListPlansReplyValidationError is the validation error returned by
// ListPlansReply.Validate if the designated constraints aren't met.
type ListPlansReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlansReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlansReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlansReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlansReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlansReplyValidationError) ErrorName() string { return "ListPlansReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListPlansReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlansReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlansReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlansReplyValidationError{}

// Validate checks the field values on GetMySubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMySubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMySubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMySubscriptionRequestMultiError, or nil if none found.
func (m *GetMySubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMySubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUid()); l < 1 || l > 36 {
		err := GetMySubscriptionRequestValidationError{
			field:  "Uid",
			reason: "value length must be between 1 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMySubscriptionRequestMultiError(errors)
	}

	return nil
}

// GetMySubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by GetMySubscriptionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetMySubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMySubscriptionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMySubscriptionRequestMultiError) AllErrors() []error { return m }

// GetMySubscriptionRequestValidationError is the validation error returned by
// GetMySubscriptionRequest.Validate if the designated constraints aren't met.
type GetMySubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMySubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMySubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMySubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMySubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMySubscriptionRequestValidationError) ErrorName() string {
	return "GetMySubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMySubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMySubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMySubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMySubscriptionRequestValidationError{}

// Validate checks the field values on GetMySubscriptionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMySubscriptionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMySubscriptionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMySubscriptionReplyMultiError, or nil if none found.
func (m *GetMySubscriptionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMySubscriptionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsActive

	// no validation rules for PlanId

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Status

	// no validation rules for AutoRenew

	if len(errors) > 0 {
		return GetMySubscriptionReplyMultiError(errors)
	}

	return nil
}

// GetMySubscriptionReplyMultiError is an error wrapping multiple validation
// errors returned by GetMySubscriptionReply.ValidateAll() if the designated
// constraints aren't met.
type GetMySubscriptionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMySubscriptionReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMySubscriptionReplyMultiError) AllErrors() []error { return m }

// GetMySubscriptionReplyValidationError is the validation error returned by
// GetMySubscriptionReply.Validate if the designated constraints aren't met.
type GetMySubscriptionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMySubscriptionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMySubscriptionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMySubscriptionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMySubscriptionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMySubscriptionReplyValidationError) ErrorName() string {
	return "GetMySubscriptionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetMySubscriptionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMySubscriptionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMySubscriptionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMySubscriptionReplyValidationError{}

// Validate checks the field values on CreateSubscriptionOrderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubscriptionOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubscriptionOrderRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateSubscriptionOrderRequestMultiError, or nil if none found.
func (m *CreateSubscriptionOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubscriptionOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUid()); l < 1 || l > 36 {
		err := CreateSubscriptionOrderRequestValidationError{
			field:  "Uid",
			reason: "value length must be between 1 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPlanId()); l < 1 || l > 50 {
		err := CreateSubscriptionOrderRequestValidationError{
			field:  "PlanId",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateSubscriptionOrderRequest_PaymentMethod_InLookup[m.GetPaymentMethod()]; !ok {
		err := CreateSubscriptionOrderRequestValidationError{
			field:  "PaymentMethod",
			reason: "value must be in list [alipay wechatpay]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Region

	if len(errors) > 0 {
		return CreateSubscriptionOrderRequestMultiError(errors)
	}

	return nil
}

// CreateSubscriptionOrderRequestMultiError is an error wrapping multiple
// validation errors returned by CreateSubscriptionOrderRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateSubscriptionOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubscriptionOrderRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubscriptionOrderRequestMultiError) AllErrors() []error { return m }

// CreateSubscriptionOrderRequestValidationError is the validation error
// returned by CreateSubscriptionOrderRequest.Validate if the designated
// constraints aren't met.
type CreateSubscriptionOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubscriptionOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubscriptionOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubscriptionOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubscriptionOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubscriptionOrderRequestValidationError) ErrorName() string {
	return "CreateSubscriptionOrderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubscriptionOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubscriptionOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubscriptionOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubscriptionOrderRequestValidationError{}

var _CreateSubscriptionOrderRequest_PaymentMethod_InLookup = map[string]struct{}{
	"alipay":    {},
	"wechatpay": {},
}

// Validate checks the field values on CreateSubscriptionOrderReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubscriptionOrderReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubscriptionOrderReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubscriptionOrderReplyMultiError, or nil if none found.
func (m *CreateSubscriptionOrderReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubscriptionOrderReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for PaymentId

	// no validation rules for PayUrl

	// no validation rules for PayCode

	// no validation rules for PayParams

	if len(errors) > 0 {
		return CreateSubscriptionOrderReplyMultiError(errors)
	}

	return nil
}

// CreateSubscriptionOrderReplyMultiError is an error wrapping multiple
// validation errors returned by CreateSubscriptionOrderReply.ValidateAll() if
// the designated constraints aren't met.
type CreateSubscriptionOrderReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubscriptionOrderReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubscriptionOrderReplyMultiError) AllErrors() []error { return m }

// CreateSubscriptionOrderReplyValidationError is the validation error returned
// by CreateSubscriptionOrderReply.Validate if the designated constraints
// aren't met.
type CreateSubscriptionOrderReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubscriptionOrderReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubscriptionOrderReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubscriptionOrderReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubscriptionOrderReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubscriptionOrderReplyValidationError) ErrorName() string {
	return "CreateSubscriptionOrderReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubscriptionOrderReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubscriptionOrderReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubscriptionOrderReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubscriptionOrderReplyValidationError{}

// Validate checks the field values on HandlePaymentSuccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandlePaymentSuccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandlePaymentSuccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandlePaymentSuccessRequestMultiError, or nil if none found.
func (m *HandlePaymentSuccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HandlePaymentSuccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetOrderId()); l < 1 || l > 100 {
		err := HandlePaymentSuccessRequestValidationError{
			field:  "OrderId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPaymentId()); l < 1 || l > 100 {
		err := HandlePaymentSuccessRequestValidationError{
			field:  "PaymentId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAmount() <= 0 {
		err := HandlePaymentSuccessRequestValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return HandlePaymentSuccessRequestMultiError(errors)
	}

	return nil
}

// HandlePaymentSuccessRequestMultiError is an error wrapping multiple
// validation errors returned by HandlePaymentSuccessRequest.ValidateAll() if
// the designated constraints aren't met.
type HandlePaymentSuccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandlePaymentSuccessRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandlePaymentSuccessRequestMultiError) AllErrors() []error { return m }

// HandlePaymentSuccessRequestValidationError is the validation error returned
// by HandlePaymentSuccessRequest.Validate if the designated constraints
// aren't met.
type HandlePaymentSuccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandlePaymentSuccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandlePaymentSuccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandlePaymentSuccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandlePaymentSuccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandlePaymentSuccessRequestValidationError) ErrorName() string {
	return "HandlePaymentSuccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HandlePaymentSuccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandlePaymentSuccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandlePaymentSuccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandlePaymentSuccessRequestValidationError{}

// Validate checks the field values on CancelSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelSubscriptionRequestMultiError, or nil if none found.
func (m *CancelSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUid()); l < 1 || l > 36 {
		err := CancelSubscriptionRequestValidationError{
			field:  "Uid",
			reason: "value length must be between 1 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return CancelSubscriptionRequestMultiError(errors)
	}

	return nil
}

// CancelSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by CancelSubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type CancelSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelSubscriptionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelSubscriptionRequestMultiError) AllErrors() []error { return m }

// CancelSubscriptionRequestValidationError is the validation error returned by
// CancelSubscriptionRequest.Validate if the designated constraints aren't met.
type CancelSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelSubscriptionRequestValidationError) ErrorName() string {
	return "CancelSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelSubscriptionRequestValidationError{}

// Validate checks the field values on PauseSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PauseSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PauseSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PauseSubscriptionRequestMultiError, or nil if none found.
func (m *PauseSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PauseSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUid()); l < 1 || l > 36 {
		err := PauseSubscriptionRequestValidationError{
			field:  "Uid",
			reason: "value length must be between 1 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return PauseSubscriptionRequestMultiError(errors)
	}

	return nil
}

// PauseSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by PauseSubscriptionRequest.ValidateAll() if the designated
// constraints aren't met.
type PauseSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PauseSubscriptionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PauseSubscriptionRequestMultiError) AllErrors() []error { return m }

// PauseSubscriptionRequestValidationError is the validation error returned by
// PauseSubscriptionRequest.Validate if the designated constraints aren't met.
type PauseSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PauseSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PauseSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PauseSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PauseSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PauseSubscriptionRequestValidationError) ErrorName() string {
	return "PauseSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PauseSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPauseSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PauseSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PauseSubscriptionRequestValidationError{}

// Validate checks the field values on ResumeSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResumeSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumeSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResumeSubscriptionRequestMultiError, or nil if none found.
func (m *ResumeSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumeSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUid()); l < 1 || l > 36 {
		err := ResumeSubscriptionRequestValidationError{
			field:  "Uid",
			reason: "value length must be between 1 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ResumeSubscriptionRequestMultiError(errors)
	}

	return nil
}

// ResumeSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by ResumeSubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type ResumeSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumeSubscriptionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumeSubscriptionRequestMultiError) AllErrors() []error { return m }

// ResumeSubscriptionRequestValidationError is the validation error returned by
// ResumeSubscriptionRequest.Validate if the designated constraints aren't met.
type ResumeSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumeSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumeSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumeSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumeSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumeSubscriptionRequestValidationError) ErrorName() string {
	return "ResumeSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResumeSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumeSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumeSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumeSubscriptionRequestValidationError{}

// Validate checks the field values on SubscriptionHistoryItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionHistoryItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionHistoryItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionHistoryItemMultiError, or nil if none found.
func (m *SubscriptionHistoryItem) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionHistoryItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PlanId

	// no validation rules for PlanName

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Status

	// no validation rules for Action

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return SubscriptionHistoryItemMultiError(errors)
	}

	return nil
}

// SubscriptionHistoryItemMultiError is an error wrapping multiple validation
// errors returned by SubscriptionHistoryItem.ValidateAll() if the designated
// constraints aren't met.
type SubscriptionHistoryItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionHistoryItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionHistoryItemMultiError) AllErrors() []error { return m }

// SubscriptionHistoryItemValidationError is the validation error returned by
// SubscriptionHistoryItem.Validate if the designated constraints aren't met.
type SubscriptionHistoryItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionHistoryItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionHistoryItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionHistoryItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionHistoryItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionHistoryItemValidationError) ErrorName() string {
	return "SubscriptionHistoryItemValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionHistoryItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionHistoryItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionHistoryItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionHistoryItemValidationError{}

// Validate checks the field values on GetSubscriptionHistoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubscriptionHistoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubscriptionHistoryRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSubscriptionHistoryRequestMultiError, or nil if none found.
func (m *GetSubscriptionHistoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubscriptionHistoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUid()); l < 1 || l > 36 {
		err := GetSubscriptionHistoryRequestValidationError{
			field:  "Uid",
			reason: "value length must be between 1 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return GetSubscriptionHistoryRequestMultiError(errors)
	}

	return nil
}

// GetSubscriptionHistoryRequestMultiError is an error wrapping multiple
// validation errors returned by GetSubscriptionHistoryRequest.ValidateAll()
// if the designated constraints aren't met.
type GetSubscriptionHistoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubscriptionHistoryRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubscriptionHistoryRequestMultiError) AllErrors() []error { return m }

// GetSubscriptionHistoryRequestValidationError is the validation error
// returned by GetSubscriptionHistoryRequest.Validate if the designated
// constraints aren't met.
type GetSubscriptionHistoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubscriptionHistoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubscriptionHistoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubscriptionHistoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubscriptionHistoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubscriptionHistoryRequestValidationError) ErrorName() string {
	return "GetSubscriptionHistoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubscriptionHistoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubscriptionHistoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubscriptionHistoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubscriptionHistoryRequestValidationError{}

// Validate checks the field values on GetSubscriptionHistoryReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubscriptionHistoryReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubscriptionHistoryReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubscriptionHistoryReplyMultiError, or nil if none found.
func (m *GetSubscriptionHistoryReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubscriptionHistoryReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSubscriptionHistoryReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSubscriptionHistoryReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSubscriptionHistoryReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return GetSubscriptionHistoryReplyMultiError(errors)
	}

	return nil
}

// GetSubscriptionHistoryReplyMultiError is an error wrapping multiple
// validation errors returned by GetSubscriptionHistoryReply.ValidateAll() if
// the designated constraints aren't met.
type GetSubscriptionHistoryReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubscriptionHistoryReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubscriptionHistoryReplyMultiError) AllErrors() []error { return m }

// GetSubscriptionHistoryReplyValidationError is the validation error returned
// by GetSubscriptionHistoryReply.Validate if the designated constraints
// aren't met.
type GetSubscriptionHistoryReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubscriptionHistoryReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubscriptionHistoryReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubscriptionHistoryReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubscriptionHistoryReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubscriptionHistoryReplyValidationError) ErrorName() string {
	return "GetSubscriptionHistoryReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubscriptionHistoryReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubscriptionHistoryReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubscriptionHistoryReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubscriptionHistoryReplyValidationError{}

// Validate checks the field values on SetAutoRenewRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetAutoRenewRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAutoRenewRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetAutoRenewRequestMultiError, or nil if none found.
func (m *SetAutoRenewRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAutoRenewRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUid()); l < 1 || l > 36 {
		err := SetAutoRenewRequestValidationError{
			field:  "Uid",
			reason: "value length must be between 1 and 36 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AutoRenew

	if len(errors) > 0 {
		return SetAutoRenewRequestMultiError(errors)
	}

	return nil
}

// SetAutoRenewRequestMultiError is an error wrapping multiple validation
// errors returned by SetAutoRenewRequest.ValidateAll() if the designated
// constraints aren't met.
type SetAutoRenewRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAutoRenewRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAutoRenewRequestMultiError) AllErrors() []error { return m }

// SetAutoRenewRequestValidationError is the validation error returned by
// SetAutoRenewRequest.Validate if the designated constraints aren't met.
type SetAutoRenewRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAutoRenewRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAutoRenewRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAutoRenewRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAutoRenewRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAutoRenewRequestValidationError) ErrorName() string {
	return "SetAutoRenewRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetAutoRenewRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAutoRenewRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAutoRenewRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAutoRenewRequestValidationError{}

// Validate checks the field values on GetExpiringSubscriptionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExpiringSubscriptionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExpiringSubscriptionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetExpiringSubscriptionsRequestMultiError, or nil if none found.
func (m *GetExpiringSubscriptionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExpiringSubscriptionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetDaysBeforeExpiry(); val < 1 || val > 30 {
		err := GetExpiringSubscriptionsRequestValidationError{
			field:  "DaysBeforeExpiry",
			reason: "value must be inside range [1, 30]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return GetExpiringSubscriptionsRequestMultiError(errors)
	}

	return nil
}

// GetExpiringSubscriptionsRequestMultiError is an error wrapping multiple
// validation errors returned by GetExpiringSubscriptionsRequest.ValidateAll()
// if the designated constraints aren't met.
type GetExpiringSubscriptionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExpiringSubscriptionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExpiringSubscriptionsRequestMultiError) AllErrors() []error { return m }

// GetExpiringSubscriptionsRequestValidationError is the validation error
// returned by GetExpiringSubscriptionsRequest.Validate if the designated
// constraints aren't met.
type GetExpiringSubscriptionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExpiringSubscriptionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExpiringSubscriptionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExpiringSubscriptionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExpiringSubscriptionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExpiringSubscriptionsRequestValidationError) ErrorName() string {
	return "GetExpiringSubscriptionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetExpiringSubscriptionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExpiringSubscriptionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExpiringSubscriptionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExpiringSubscriptionsRequestValidationError{}

// Validate checks the field values on SubscriptionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionInfoMultiError, or nil if none found.
func (m *SubscriptionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for PlanId

	// no validation rules for PlanName

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for AutoRenew

	// no validation rules for Amount

	if len(errors) > 0 {
		return SubscriptionInfoMultiError(errors)
	}

	return nil
}

// SubscriptionInfoMultiError is an error wrapping multiple validation errors
// returned by SubscriptionInfo.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionInfoMultiError) AllErrors() []error { return m }

// SubscriptionInfoValidationError is the validation error returned by
// SubscriptionInfo.Validate if the designated constraints aren't met.
type SubscriptionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionInfoValidationError) ErrorName() string { return "SubscriptionInfoValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionInfoValidationError{}

// Validate checks the field values on GetExpiringSubscriptionsReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExpiringSubscriptionsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExpiringSubscriptionsReply with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetExpiringSubscriptionsReplyMultiError, or nil if none found.
func (m *GetExpiringSubscriptionsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExpiringSubscriptionsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetExpiringSubscriptionsReplyValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetExpiringSubscriptionsReplyValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetExpiringSubscriptionsReplyValidationError{
					field:  fmt.Sprintf("Subscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return GetExpiringSubscriptionsReplyMultiError(errors)
	}

	return nil
}

// GetExpiringSubscriptionsReplyMultiError is an error wrapping multiple
// validation errors returned by GetExpiringSubscriptionsReply.ValidateAll()
// if the designated constraints aren't met.
type GetExpiringSubscriptionsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExpiringSubscriptionsReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExpiringSubscriptionsReplyMultiError) AllErrors() []error { return m }

// GetExpiringSubscriptionsReplyValidationError is the validation error
// returned by GetExpiringSubscriptionsReply.Validate if the designated
// constraints aren't met.
type GetExpiringSubscriptionsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExpiringSubscriptionsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExpiringSubscriptionsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExpiringSubscriptionsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExpiringSubscriptionsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExpiringSubscriptionsReplyValidationError) ErrorName() string {
	return "GetExpiringSubscriptionsReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetExpiringSubscriptionsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExpiringSubscriptionsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExpiringSubscriptionsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExpiringSubscriptionsReplyValidationError{}

// Validate checks the field values on UpdateExpiredSubscriptionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateExpiredSubscriptionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateExpiredSubscriptionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateExpiredSubscriptionsRequestMultiError, or nil if none found.
func (m *UpdateExpiredSubscriptionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateExpiredSubscriptionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateExpiredSubscriptionsRequestMultiError(errors)
	}

	return nil
}

// UpdateExpiredSubscriptionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateExpiredSubscriptionsRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateExpiredSubscriptionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateExpiredSubscriptionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateExpiredSubscriptionsRequestMultiError) AllErrors() []error { return m }

// UpdateExpiredSubscriptionsRequestValidationError is the validation error
// returned by UpdateExpiredSubscriptionsRequest.Validate if the designated
// constraints aren't met.
type UpdateExpiredSubscriptionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateExpiredSubscriptionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateExpiredSubscriptionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateExpiredSubscriptionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateExpiredSubscriptionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateExpiredSubscriptionsRequestValidationError) ErrorName() string {
	return "UpdateExpiredSubscriptionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateExpiredSubscriptionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateExpiredSubscriptionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateExpiredSubscriptionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateExpiredSubscriptionsRequestValidationError{}

// Validate checks the field values on UpdateExpiredSubscriptionsReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateExpiredSubscriptionsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateExpiredSubscriptionsReply with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateExpiredSubscriptionsReplyMultiError, or nil if none found.
func (m *UpdateExpiredSubscriptionsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateExpiredSubscriptionsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UpdatedCount

	if len(errors) > 0 {
		return UpdateExpiredSubscriptionsReplyMultiError(errors)
	}

	return nil
}

// UpdateExpiredSubscriptionsReplyMultiError is an error wrapping multiple
// validation errors returned by UpdateExpiredSubscriptionsReply.ValidateAll()
// if the designated constraints aren't met.
type UpdateExpiredSubscriptionsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateExpiredSubscriptionsReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateExpiredSubscriptionsReplyMultiError) AllErrors() []error { return m }

// UpdateExpiredSubscriptionsReplyValidationError is the validation error
// returned by UpdateExpiredSubscriptionsReply.Validate if the designated
// constraints aren't met.
type UpdateExpiredSubscriptionsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateExpiredSubscriptionsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateExpiredSubscriptionsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateExpiredSubscriptionsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateExpiredSubscriptionsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateExpiredSubscriptionsReplyValidationError) ErrorName() string {
	return "UpdateExpiredSubscriptionsReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateExpiredSubscriptionsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateExpiredSubscriptionsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateExpiredSubscriptionsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateExpiredSubscriptionsReplyValidationError{}

// Validate checks the field values on ProcessAutoRenewalsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessAutoRenewalsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessAutoRenewalsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessAutoRenewalsRequestMultiError, or nil if none found.
func (m *ProcessAutoRenewalsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessAutoRenewalsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetDaysBeforeExpiry(); val < 1 || val > 30 {
		err := ProcessAutoRenewalsRequestValidationError{
			field:  "DaysBeforeExpiry",
			reason: "value must be inside range [1, 30]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DryRun

	if len(errors) > 0 {
		return ProcessAutoRenewalsRequestMultiError(errors)
	}

	return nil
}

// ProcessAutoRenewalsRequestMultiError is an error wrapping multiple
// validation errors returned by ProcessAutoRenewalsRequest.ValidateAll() if
// the designated constraints aren't met.
type ProcessAutoRenewalsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessAutoRenewalsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessAutoRenewalsRequestMultiError) AllErrors() []error { return m }

// ProcessAutoRenewalsRequestValidationError is the validation error returned
// by ProcessAutoRenewalsRequest.Validate if the designated constraints aren't met.
type ProcessAutoRenewalsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessAutoRenewalsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessAutoRenewalsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessAutoRenewalsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessAutoRenewalsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessAutoRenewalsRequestValidationError) ErrorName() string {
	return "ProcessAutoRenewalsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessAutoRenewalsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessAutoRenewalsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessAutoRenewalsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessAutoRenewalsRequestValidationError{}

// Validate checks the field values on AutoRenewResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AutoRenewResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoRenewResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoRenewResultMultiError, or nil if none found.
func (m *AutoRenewResult) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoRenewResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for PlanId

	// no validation rules for Success

	// no validation rules for OrderId

	// no validation rules for PaymentId

	// no validation rules for ErrorMessage

	if len(errors) > 0 {
		return AutoRenewResultMultiError(errors)
	}

	return nil
}

// AutoRenewResultMultiError is an error wrapping multiple validation errors
// returned by AutoRenewResult.ValidateAll() if the designated constraints
// aren't met.
type AutoRenewResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoRenewResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoRenewResultMultiError) AllErrors() []error { return m }

// AutoRenewResultValidationError is the validation error returned by
// AutoRenewResult.Validate if the designated constraints aren't met.
type AutoRenewResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoRenewResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoRenewResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoRenewResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoRenewResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoRenewResultValidationError) ErrorName() string { return "AutoRenewResultValidationError" }

// Error satisfies the builtin error interface
func (e AutoRenewResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoRenewResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoRenewResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoRenewResultValidationError{}

// Validate checks the field values on ProcessAutoRenewalsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessAutoRenewalsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessAutoRenewalsReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessAutoRenewalsReplyMultiError, or nil if none found.
func (m *ProcessAutoRenewalsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessAutoRenewalsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalCount

	// no validation rules for SuccessCount

	// no validation rules for FailedCount

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProcessAutoRenewalsReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProcessAutoRenewalsReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProcessAutoRenewalsReplyValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProcessAutoRenewalsReplyMultiError(errors)
	}

	return nil
}

// ProcessAutoRenewalsReplyMultiError is an error wrapping multiple validation
// errors returned by ProcessAutoRenewalsReply.ValidateAll() if the designated
// constraints aren't met.
type ProcessAutoRenewalsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessAutoRenewalsReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessAutoRenewalsReplyMultiError) AllErrors() []error { return m }

// ProcessAutoRenewalsReplyValidationError is the validation error returned by
// ProcessAutoRenewalsReply.Validate if the designated constraints aren't met.
type ProcessAutoRenewalsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessAutoRenewalsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessAutoRenewalsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessAutoRenewalsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessAutoRenewalsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessAutoRenewalsReplyValidationError) ErrorName() string {
	return "ProcessAutoRenewalsReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessAutoRenewalsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessAutoRenewalsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessAutoRenewalsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessAutoRenewalsReplyValidationError{}

// Validate checks the field values on PlanPricing with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlanPricing) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlanPricing with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlanPricingMultiError, or
// nil if none found.
func (m *PlanPricing) ValidateAll() error {
	return m.validate(true)
}

func (m *PlanPricing) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlanPricingId

	// no validation rules for PlanId

	// no validation rules for CountryCode

	// no validation rules for Price

	// no validation rules for Currency

	if len(errors) > 0 {
		return PlanPricingMultiError(errors)
	}

	return nil
}

// PlanPricingMultiError is an error wrapping multiple validation errors
// returned by PlanPricing.ValidateAll() if the designated constraints aren't met.
type PlanPricingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlanPricingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlanPricingMultiError) AllErrors() []error { return m }

// PlanPricingValidationError is the validation error returned by
// PlanPricing.Validate if the designated constraints aren't met.
type PlanPricingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlanPricingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlanPricingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlanPricingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlanPricingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlanPricingValidationError) ErrorName() string { return "PlanPricingValidationError" }

// Error satisfies the builtin error interface
func (e PlanPricingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlanPricing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlanPricingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlanPricingValidationError{}

// Validate checks the field values on ListPlanPricingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanPricingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanPricingsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanPricingsRequestMultiError, or nil if none found.
func (m *ListPlanPricingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanPricingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlanId()) < 1 {
		err := ListPlanPricingsRequestValidationError{
			field:  "PlanId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListPlanPricingsRequestMultiError(errors)
	}

	return nil
}

// ListPlanPricingsRequestMultiError is an error wrapping multiple validation
// errors returned by ListPlanPricingsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListPlanPricingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanPricingsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanPricingsRequestMultiError) AllErrors() []error { return m }

// ListPlanPricingsRequestValidationError is the validation error returned by
// ListPlanPricingsRequest.Validate if the designated constraints aren't met.
type ListPlanPricingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanPricingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanPricingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanPricingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanPricingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanPricingsRequestValidationError) ErrorName() string {
	return "ListPlanPricingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanPricingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanPricingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanPricingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanPricingsRequestValidationError{}

// Validate checks the field values on ListPlanPricingsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanPricingsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanPricingsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanPricingsReplyMultiError, or nil if none found.
func (m *ListPlanPricingsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanPricingsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPricings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPlanPricingsReplyValidationError{
						field:  fmt.Sprintf("Pricings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPlanPricingsReplyValidationError{
						field:  fmt.Sprintf("Pricings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPlanPricingsReplyValidationError{
					field:  fmt.Sprintf("Pricings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPlanPricingsReplyMultiError(errors)
	}

	return nil
}

// ListPlanPricingsReplyMultiError is an error wrapping multiple validation
// errors returned by ListPlanPricingsReply.ValidateAll() if the designated
// constraints aren't met.
type ListPlanPricingsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanPricingsReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanPricingsReplyMultiError) AllErrors() []error { return m }

// ListPlanPricingsReplyValidationError is the validation error returned by
// ListPlanPricingsReply.Validate if the designated constraints aren't met.
type ListPlanPricingsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanPricingsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanPricingsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanPricingsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanPricingsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanPricingsReplyValidationError) ErrorName() string {
	return "ListPlanPricingsReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanPricingsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanPricingsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanPricingsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanPricingsReplyValidationError{}

// Validate checks the field values on CreatePlanPricingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePlanPricingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePlanPricingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePlanPricingRequestMultiError, or nil if none found.
func (m *CreatePlanPricingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePlanPricingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlanId()) < 1 {
		err := CreatePlanPricingRequestValidationError{
			field:  "PlanId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCountryCode()) != 2 {
		err := CreatePlanPricingRequestValidationError{
			field:  "CountryCode",
			reason: "value length must be 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if m.GetPrice() <= 0 {
		err := CreatePlanPricingRequestValidationError{
			field:  "Price",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCurrency()) != 3 {
		err := CreatePlanPricingRequestValidationError{
			field:  "Currency",
			reason: "value length must be 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return CreatePlanPricingRequestMultiError(errors)
	}

	return nil
}

// CreatePlanPricingRequestMultiError is an error wrapping multiple validation
// errors returned by CreatePlanPricingRequest.ValidateAll() if the designated
// constraints aren't met.
type CreatePlanPricingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePlanPricingRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePlanPricingRequestMultiError) AllErrors() []error { return m }

// CreatePlanPricingRequestValidationError is the validation error returned by
// CreatePlanPricingRequest.Validate if the designated constraints aren't met.
type CreatePlanPricingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePlanPricingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePlanPricingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePlanPricingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePlanPricingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePlanPricingRequestValidationError) ErrorName() string {
	return "CreatePlanPricingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePlanPricingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePlanPricingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePlanPricingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePlanPricingRequestValidationError{}

// Validate checks the field values on CreatePlanPricingReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePlanPricingReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePlanPricingReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePlanPricingReplyMultiError, or nil if none found.
func (m *CreatePlanPricingReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePlanPricingReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPricing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePlanPricingReplyValidationError{
					field:  "Pricing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePlanPricingReplyValidationError{
					field:  "Pricing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPricing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePlanPricingReplyValidationError{
				field:  "Pricing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePlanPricingReplyMultiError(errors)
	}

	return nil
}

// CreatePlanPricingReplyMultiError is an error wrapping multiple validation
// errors returned by CreatePlanPricingReply.ValidateAll() if the designated
// constraints aren't met.
type CreatePlanPricingReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePlanPricingReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePlanPricingReplyMultiError) AllErrors() []error { return m }

// CreatePlanPricingReplyValidationError is the validation error returned by
// CreatePlanPricingReply.Validate if the designated constraints aren't met.
type CreatePlanPricingReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePlanPricingReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePlanPricingReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePlanPricingReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePlanPricingReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePlanPricingReplyValidationError) ErrorName() string {
	return "CreatePlanPricingReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePlanPricingReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePlanPricingReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePlanPricingReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePlanPricingReplyValidationError{}

// Validate checks the field values on UpdatePlanPricingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePlanPricingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePlanPricingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePlanPricingRequestMultiError, or nil if none found.
func (m *UpdatePlanPricingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePlanPricingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPlanPricingId() <= 0 {
		err := UpdatePlanPricingRequestValidationError{
			field:  "PlanPricingId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPrice() <= 0 {
		err := UpdatePlanPricingRequestValidationError{
			field:  "Price",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCurrency()) != 3 {
		err := UpdatePlanPricingRequestValidationError{
			field:  "Currency",
			reason: "value length must be 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return UpdatePlanPricingRequestMultiError(errors)
	}

	return nil
}

// UpdatePlanPricingRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePlanPricingRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePlanPricingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePlanPricingRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePlanPricingRequestMultiError) AllErrors() []error { return m }

// UpdatePlanPricingRequestValidationError is the validation error returned by
// UpdatePlanPricingRequest.Validate if the designated constraints aren't met.
type UpdatePlanPricingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePlanPricingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePlanPricingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePlanPricingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePlanPricingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePlanPricingRequestValidationError) ErrorName() string {
	return "UpdatePlanPricingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePlanPricingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePlanPricingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePlanPricingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePlanPricingRequestValidationError{}

// Validate checks the field values on UpdatePlanPricingReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePlanPricingReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePlanPricingReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePlanPricingReplyMultiError, or nil if none found.
func (m *UpdatePlanPricingReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePlanPricingReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPricing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePlanPricingReplyValidationError{
					field:  "Pricing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePlanPricingReplyValidationError{
					field:  "Pricing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPricing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePlanPricingReplyValidationError{
				field:  "Pricing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePlanPricingReplyMultiError(errors)
	}

	return nil
}

// UpdatePlanPricingReplyMultiError is an error wrapping multiple validation
// errors returned by UpdatePlanPricingReply.ValidateAll() if the designated
// constraints aren't met.
type UpdatePlanPricingReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePlanPricingReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePlanPricingReplyMultiError) AllErrors() []error { return m }

// UpdatePlanPricingReplyValidationError is the validation error returned by
// UpdatePlanPricingReply.Validate if the designated constraints aren't met.
type UpdatePlanPricingReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePlanPricingReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePlanPricingReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePlanPricingReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePlanPricingReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePlanPricingReplyValidationError) ErrorName() string {
	return "UpdatePlanPricingReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePlanPricingReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePlanPricingReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePlanPricingReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePlanPricingReplyValidationError{}

// Validate checks the field values on DeletePlanPricingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePlanPricingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePlanPricingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePlanPricingRequestMultiError, or nil if none found.
func (m *DeletePlanPricingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePlanPricingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPlanPricingId() <= 0 {
		err := DeletePlanPricingRequestValidationError{
			field:  "PlanPricingId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePlanPricingRequestMultiError(errors)
	}

	return nil
}

// DeletePlanPricingRequestMultiError is an error wrapping multiple validation
// errors returned by DeletePlanPricingRequest.ValidateAll() if the designated
// constraints aren't met.
type DeletePlanPricingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePlanPricingRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePlanPricingRequestMultiError) AllErrors() []error { return m }

// DeletePlanPricingRequestValidationError is the validation error returned by
// DeletePlanPricingRequest.Validate if the designated constraints aren't met.
type DeletePlanPricingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePlanPricingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePlanPricingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePlanPricingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePlanPricingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePlanPricingRequestValidationError) ErrorName() string {
	return "DeletePlanPricingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePlanPricingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePlanPricingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePlanPricingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePlanPricingRequestValidationError{}

// Validate checks the field values on DeletePlanPricingReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePlanPricingReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePlanPricingReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePlanPricingReplyMultiError, or nil if none found.
func (m *DeletePlanPricingReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePlanPricingReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlanPricingId

	if len(errors) > 0 {
		return DeletePlanPricingReplyMultiError(errors)
	}

	return nil
}

// DeletePlanPricingReplyMultiError is an error wrapping multiple validation
// errors returned by DeletePlanPricingReply.ValidateAll() if the designated
// constraints aren't met.
type DeletePlanPricingReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePlanPricingReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePlanPricingReplyMultiError) AllErrors() []error { return m }

// DeletePlanPricingReplyValidationError is the validation error returned by
// DeletePlanPricingReply.Validate if the designated constraints aren't met.
type DeletePlanPricingReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePlanPricingReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePlanPricingReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePlanPricingReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePlanPricingReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePlanPricingReplyValidationError) ErrorName() string {
	return "DeletePlanPricingReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePlanPricingReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePlanPricingReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePlanPricingReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePlanPricingReplyValidationError{}
